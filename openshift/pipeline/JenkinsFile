#!/usr/bin/env groovy

@Library('pipelines@tesing-vars') _

def GIT_REPO = "github.com/cfoskin/migration-mainlines-cloud.git";
def GIT_BRANCH = 'jenkins-pipeline-setup';
def APP_VERSION = '';
def STASHED_ARTIFACT = 'buildArtifact'
def DEV_NAMESPACE = 'nr-dev-cf'
def APP_NAME = 'develop'

pipeline {


  agent {
	  label 'nodejs6'
	}

  stages{

    stage('Init'){
      // Set up the build directory and delete the old one. This can be extended if needed.
      steps {
        script {
          sh 'node --version '
          init()
        }
      }
    }
    
    stage('Set branch') {
      // Let the user input what branch to build, defaults to the develop branch as per spec.
      steps {
        script {
          try {
              timeout(time: 60, unit: 'SECONDS') {
                  GIT_BRANCH = input(
                      message: 'Set branch name:',
                      parameters: [
                          string(name: "branchName", description: "Branch to deploy, the default is ${GIT_BRANCH}", defaultValue: "${GIT_BRANCH}")
                      ]
                  )
              }
          } catch(err) { } // catch the timeout error, proceed despite the error
        }
      }
    }

    stage('Clone') {
      // Clone the source code using the git branch specified previously
      steps {
        script {
          dir('oc-build') {
              git branch:"${GIT_BRANCH}", url:"https://${GIT_REPO}"
          }
        }
      }
      // shared lib, pass in default as a param or default to develop. Default the default
      // Prompt for branch/tag, default to develop, Jannes example good here
      // Need ot be able to accept a branch or tag
    }

     stage('Set Version'){
       // Get the version from the package.json of the node app and store this for the image tagging.
        steps {
          script {
            dir('oc-build') {
            APP_VERSION = version()
            echo "tag for image build: ${APP_VERSION}"
            }
          }
        }
    }

    stage('Build Code'){
      // Build the code 

      steps {
        script {
          dir('oc-build'){
            // install dependencies
            sh 'npm install'
            sh 'npm run build'
            // create the tar file
            writeFile file: 'dist/VERSION', text: "${APP_VERSION}"
            sh 'tar --exclude=".git" --exclude="./node_modules" -cvf ./archive.tar ./ || [[ $? -eq 1 ]]'
            // Stash the build artifact
            stash includes: 'archive.tar', name: STASHED_ARTIFACT
            sh 'mkdir stash_test' //for testing
          }
        }
      }
      // can be shared lib???
      // npm install
      // npm build
      // tar artifact
      // stash

    }

    stage('QA Code'){
      // Call out to unit tests, sonarqube etc..
      steps {
        script {
          sh 'echo "Running the QA Code Stage (Unit tests, SonarQube etc...)" '
        }
      }

    }

    stage('Build Image'){
     // Perform the Openshift build 
      steps {
        script {
           openshift.withProject(DEV_NAMESPACE) {
            dir('oc-build'){
              def dc = openshift.selector( "dc/${APP_NAME}")
              if(dc.exists()) {
                  echo "Removing trigger for Deployment config"
                  openshift.set("triggers", "dc/${APP_NAME}", "--from-config", "--remove")
                  openshift.set("triggers", "dc/${APP_NAME}", "--from-image=${DEV_NAMESPACE}/${APP_NAME}:latest", "--remove")
              } else {
                  echo "No deployment exists"
              }

              unstash name: STASHED_ARTIFACT

              def bc = openshift.selector('bc', "${APP_NAME}")
              bc.startBuild("--from-archive=archive.tar")
              bc.logs('-f')
              def builds = bc.related('builds')

              timeout(2) {
                  builds.untilEach(1) {
                      return it.object().status.phase == 'Complete'
                  }
              } 
            }
          }
        }
      }
    }

    stage('Deploy to Dev'){
      //Deploy the image to the dev environment but manage environment variables first with configmaps, secrets etc
        script {
          openshift.withProject(DEV_NAMESPACE) {
              dir('oc-build'){
                sh 'echo "Running the Deploy to Dev Stage" '
                sh 'echo "Managing Environment Variables" '

                def cmEnv = "openshift/properties/configmaps/dev.properties"
          
                def cfgEnv = openshift.selector("cm/${APP_NAME}-cm-env")
                if (cfgEnv.exists()) {
                  cfgEnv.delete()
                }
                if (fileExists(cmEnv)) {
                    openshift.create("configmap", "${APP_NAME}-cm-env", "--from-env-file=${cmEnv}")
                } else {
                    echo 'No CM-ENV file Exists'
                }


                echo "Rolling out Deployment of Application.."
                def dcObj = dc.object()
                def dc = openshift.selector( "dc/${APP_NAME}")
                if (dc.exists()) {
                  if (cfgEnv.exists()) {
                    openshift.set("env", "dc/${APP_NAME}", "--from=configmap/${APP_NAME}-cm-env")
                    dc.rollout().latest()
                  }
               }
               
                echo "Verifying Application deployment has been rolled out.."
                def dcObj = dc.object()
                def podSelector = openshift.selector('pod', [deployment: "${APP_NAME}-${dcObj.status.latestVersion}"])
                podSelector.untilEach {
                    echo "VERIFY pod: ${it.name()}"
                    return it.object().status.containerStatuses[0].ready
                }

              }
           }
        }
      }      
    }

    stage('QA Image in Dev'){
      // Blank for now - Maybe Pause here
      // Automated black box testing / functioanl testing / API testing etc 
      steps {
        script {
          sh 'echo "Running the QA Image Stage" '
        }
      }        
    }

    // stage('Deploy to Test'){
    //   // TODO: Describe purpose of Deploy to Test
      

    //   // only runs for master and hotfix branches - add check
    //   // Prompt user if they want to move specific version image to test
    //   // TAg it // possibly shared lib

    //   // Similar to "Deploy to Dev"

    //   steps {
    //     script {
    //       sh 'echo "Running the Deploy to Test Stage" '
    //     }
    //   }        

    // }

    // stage('Prepare Image for Prod'){
    //   // TODO: Describe purpose of Prepare Image for Prod

    //   steps {
    //     script {
    //       sh 'echo "Running the Prepare Image for Prod Stage" '
    //     }
    //   }  
      
    //   // NOTE: this entire step is probably not required for the spike

    //   // only runs for master and hotfix branches

    //   // only runs for master and hotfix branches - add check
    //   // Prompt user if they want to move specific version image to test
    //   // Tag it // possibly shared lib

    //   // Push using Skopeo

    //   // ISSUE HERE!!!!
    //   // ISSUE HERE!!!!
      
    //   // What happens in the scenario where the QA manual testing takes a week?
    //   // Does the pipeline pause?
    //   // Could be a backlog of executing pipelines?
    //   // Look at milestones and     runPolicy: SerialLatestOnly

    //   // Stick in Nexus instead of Remote registry
    // }

  }
}

// plugins
// Openshift client plugin v1.0.7 (https://updates.jenkins.io/download/plugins/openshift-client/1.0.7/openshift-client.hpi).                done! 
// Multibranch pipeline plugin v2.15 (https://updates.jenkins.io/download/plugins/workflow-multibranch/2.15/workflow-multibranch.hpi)       done! 
// HTML Publisher v1.16 (https://updates.jenkins.io/download/plugins/htmlpublisher/1.16/htmlpublisher.hpi)
// Milestones plugin v1.3 (https://updates.jenkins.io/download/plugins/pipeline-milestone-step/1.3/pipeline-milestone-step.hpi)













