#!/usr/bin/env groovy

@Library('pipelines') _

def GIT_BRANCH = 'develop'


pipeline {


  agent {
	  label 'nodejs4'
	}

  stages{

    
    stage('Init'){
      // Set up the build directory and delete the old one. This can be extended if needed.
      steps {
        script {
          init()
        }
      }
    }

    stage('Set branch') {
      // Let the user input what branch to build, defaults to the develop branch as per spec.
      steps {
        script {
          try {
              timeout(time: 60, unit: 'SECONDS') {
                  GIT_BRANCH = input(
                      message: 'Set branch name:',
                      parameters: [
                          string(name: "branchName", description: "Branch to deploy, the default is ${GIT_BRANCH}", defaultValue: "${GIT_BRANCH}")
                      ]
                  )
              }
          } catch(err) { } // catch the timeout error, proceed despite the error
        }
      }
    }

    stage('Clone') {
      // Clone the source code using the git branch specified previously
      steps {
        script {
          dir('oc-build') {
              git branch:"${GIT_BRANCH}", url:"https://${GIT_REPO}"
          }
        }
      }
      // shared lib, pass in default as a param or default to develop. Default the default
      // Prompt for branch/tag, default to develop, Jannes example good here
      // Need ot be able to accept a branch or tag
    }

    stage('Set Version'){
       // Get the version from the package.json of the node app and store this for the image tagging. Need the repo cloned to actually do this
        steps {
          script {
            dir('oc-build') {
            APP_VERSION = version()
            echo "tag for image build: ${APP_VERSION}"
            }
          }
        }
    }

     stage('Build Code'){
      // Build the code 

      steps {
        script {
          dir('oc-build'){
            // install dependencies
            sh 'npm install'
            sh 'npm run build'
            // create the tar file
            writeFile file: 'dist/VERSION', text: "${APP_VERSION}"
            sh 'tar --exclude=".git" --exclude="./node_modules" -cvf ./archive.tar ./ || [[ $? -eq 1 ]]'
            // Stash the build artifact
            stash includes: 'archive.tar', name: STASHED_ARTIFACT
            sh 'mkdir stash_test' //for testing
          }
        }
      }
      // can be shared lib???
      // npm install
      // npm build
      // tar artifact
      // stash

    }

    stage('QA Code'){
      // Call out to unit tests, sonarqube etc..
      steps {
        script {
          sh 'echo "Running the QA Code Stage (Unit tests, SonarQube etc...)" '
        }
      }

    }

     stage('Build Image'){
      // TODO: Describe purpose of Build Image
      steps {
        script {
           openshift.withProject(DEV_NAMESPACE) {
            dir('oc-build'){
              def dc = openshift.selector( "dc/${APP_NAME}")
              if(dc.exists()) {
                  echo "Removing trigger for Deployment config"
                  openshift.set("triggers", "dc/${APP_NAME}", "--from-config", "--remove")
                 // openshift.set("triggers", "dc/${APP_NAME}", "--from-image", "--remove")
              } else {
                  echo "No deployment exists"
              }

              sh 'ls -l'

              unstash name: STASHED_ARTIFACT

              sh 'ls -l'

              def bc = openshift.selector('bc', "${APP_NAME}")
              bc.startBuild("--from-archive=archive.tar")
              bc.logs('-f')
              def builds = bc.related('builds')

              timeout(2) {
                  builds.untilEach(1) {
                      return it.object().status.phase == 'Complete'
                  }
              } 
            }
          }
        }
      }
      // Shared lib
      // openshiftNodejsBuild
      // see Mikels openshiftBuildAndDeploy.groovy
    }

    stage('Deploy to Dev'){
      // TODO: Describe purpose of Deploy to Dev
      steps {
        script {
          sh 'echo "Running the Deploy to Dev Stage" '
        }
      }      

      // Step1 
      // Configuration Management
      // Delete all and recreate - use folder structure in code base as a convention
      // Config Map       // shared lib
      // Secrets          // shared lib
      // Environments etc // shared lib


      // Step 2
      // Shared Lib
      // Simple Deploy to Dev
        // See below from Janne
        // def dc = openshift.selector('dc', "${applicationName}")
        // dcmap = dc.object()
        // dcmap.spec.template.spec.containers[0].image = "${registry}/${registryNamespace}/${imageStream}:${imageTag}"
        // dcmap.spec.replicas = replicaCount
        // openshift.apply(dcmap)

      // Step 3
      // Apply newly created Configm Maps and Secrets
      // Might require patching the deployment config
      // Patch the DC because its a variable number of things. Just with the Config Map stuff, not a full template

      // NOTE:
      // For the spike we might hard code the adding of the config map as the above functioanlity will take some time
    }

    stage('QA Image'){
      // TODO: Describe purpose of QA Image
      // Blank for now
      // Automated black box testing / functioanl testing / API testing etc 
      steps {
        script {
          sh 'echo "Running the QA Image Stage" '
        }
      }        
    }

    stage('Deploy to Test'){
      // TODO: Describe purpose of Deploy to Test
      

      // only runs for master and hotfix branches - add check
      // Prompt user if they want to move specific version image to test
      // TAg it // possibly shared lib

      // Similar to "Deploy to Dev"

      steps {
        script {
          sh 'echo "Running the Deploy to Test Stage" '
        }
      }        

    }

    stage('Prepare Image for Prod'){
      // TODO: Describe purpose of Prepare Image for Prod

      steps {
        script {
          sh 'echo "Running the Prepare Image for Prod Stage" '
        }
      }  
      
      // NOTE: this entire step is probably not required for the spike

      // only runs for master and hotfix branches

      // only runs for master and hotfix branches - add check
      // Prompt user if they want to move specific version image to test
      // Tag it // possibly shared lib

      // Push using Skopeo

      // ISSUE HERE!!!!
      // ISSUE HERE!!!!
      
      // What happens in the scenario where the QA manual testing takes a week?
      // Does the pipeline pause?
      // Could be a backlog of executing pipelines?
      // Look at milestones and     runPolicy: SerialLatestOnly

      // Stick in Nexus instead of Remote registry
    }

  }
}

// plugins
// Openshift client plugin v1.0.7 (https://updates.jenkins.io/download/plugins/openshift-client/1.0.7/openshift-client.hpi).                done! 
// Multibranch pipeline plugin v2.15 (https://updates.jenkins.io/download/plugins/workflow-multibranch/2.15/workflow-multibranch.hpi)       done! 
// HTML Publisher v1.16 (https://updates.jenkins.io/download/plugins/htmlpublisher/1.16/htmlpublisher.hpi)
// Milestones plugin v1.3 (https://updates.jenkins.io/download/plugins/pipeline-milestone-step/1.3/pipeline-milestone-step.hpi)














